# TCP/IP

## 01. TCP/IP 모델

- Application layer (http, 브라우저)
- Transport layer (TCP/UDP)
- Internet layer (IP)
- Network Access layer (인터넷)

## 02. TCP 동작과정

- 소켓 생성 => 3way Handshake(연결) => 데이터 송신, 수신 => 4way Handshake(연결끊기)

### TCP 헤더

![b_concept_3112](./img/b_concept_3112.png)

#### 01) 소켓 생성

- 브라우저에서 소켓을 호출(도메인과 사용할 타입인 TCP를 설정해서 호출하게됨) => 프로토콜 스택(OS의 네트워크 제어용 소프트웨어)이 받아서 소켓 작성 => 디스크립터(소켓의 번호표) 반환

![b_concept_32724](./img/b_concept_32724.png)

#### 02) 3way Handshake

- 브라우저에서 디스크립터, IP 주소, 포트 번호를 넣어서 호출 => 요청을 받은 프로토콜 스택이 웹서버로 요청을 보냄

![b_concept_3307](./img/b_concept_3307.png)

- 좀 더 디테일하게 보자면

1.  클라이언트에서 시퀀스 번호 초기화 => 초기화 한 번호를 공유하기 위해서 SYN(컨트롤 비트) 설정을 해서 서버로 보내줌

![b_concept_8159](./img/b_concept_8159.png)

2. 서버에서 시퀀스 번호를 초기화를 해서 => 서버에서 생성한 시퀀스 번호를 공유 => 클라이언트로 받았던 시퀀스 번호가 잘 도착했다는 것을 알리기 위해 ACK 번호를 설정 => 클라이언트로 데이터를 보냄

![b_concept_8339](./img/b_concept_8339.png)

3.서버에서 시퀀스 번호를 받았다는것을 서버에 알려주기 위해서 => ACK 번호를 설정해서 서버로 데이터를 보냄

![b_concept_8539](./img/b_concept_8539.png)

> 이러한 일련의 과정을 통해 서버와 클라이언트는 연결을 맺게 된다.

- 와이어 샤크를 통해 살펴보자

- 왜 ? 시퀀스 넘버와 아크넘버가 난수로 설정되어 있을까 ?
  포트는 유한하기 때문에 같은 포트가 사용될 가능성이 있음. 그래서 서버와 포트가 각각 같은 포트를 사용할수도 있기 때문에 서버에서는 패킷을 구분하기 위해서 시퀀스 넘버를 통해서 구분하게 됨 => 그런데 순차적인 시퀀스 넘버를 사용하게 되면 이전 커넥션으로부터 온 패킷으로 인지를 할 가능성이 있어서 서버에서 인지 할 수 있도록 난수를 생성해서 패킷을 보내주는거임

![b_concept_83347](./img/b_concept_83347.png)

#### 03) 데이터 송신, 수신

1. 클라이언트에선 write()를 호출 => 브라우저에서 받은 Http Request 메세지를 받아서 패킷으로 만들어서 서버에 전달

![b_concept_84140](./img/b_concept_84140.png)

2. 이걸 받은 서버는 응답을 하기 위해서 데이터를 만들고 패킷을 만들어서 클라이언트에 보내게 되면, 클라이언트는 read를 호출해서 데이터를 읽게 됨

![b_concept_84531](./img/b_concept_84531.png)

- 중간에 패킷이 이렇게 소실되면(클라이언트는 서버로부터 일정 시간동안 응답이 오지 않으면) 이전 패킷을 다시 재전송해서 요청을 하게됨, 이랬는데도 요청에 응답이 오지 않으면, 클라이언트에서는 데이터 송신 작업을 강제로 종료 => 어플리케이션에 오류를 반환함

![b_concept_84840](./img/b_concept_84840.png)

- 데이터 송수신에서 주고 받아지는 패킷을 보자면

  - TCP segment(TCP 헤더 & 데이터) length => 보낸데이터(557bytes) => 받은데이터(558bytes => 이미 한번 시퀀스 번호를 주고 받았기 때문에 + 1 이 된거임)

![b_concept_85134](./img/b_concept_85134.png)

#### 04) 4way Handshake

- 연결 끊기 동작을 위한 `4way Handshake`

1. 클라이언트에서는 close 를 호출하게 되면 => FIN _(TCP 헤더에 연결 끊기를 나타내는 컨트롤비트)_ 을 설정해서 서버에 보내줌

   ![b_concept_10344](./img/b_concept_10344.png)

2. 서버는 이 FIN 에 대한 응답으로 ACK 를 설정해서 응답을 함 => 클라이언트는 서버로 부터 FIN 응답이 올때까지 기다리는 상태가 됨

   ![b_concept_10542](./img/b_concept_10542.png)

3. 서버에서 보낼 데이터가 없다면 바로 close 를 호출 => 컨트롤 비트, FIN 을 설정해서 클라이언트로 보냄

   ![b_concept_10712](./img/b_concept_10712.png)

4. 클라이언트에서는 잘받았다는 의미로 ACK 번호를 설정함 => 서버로 전송 => 클라이언트 소켓이 말소(바로 말소되지 x => 서버가 ACK패킷을 받지 못했을경우 다시 재요청을 할수 있기 때문에) => 연결이 끊김

   ![b_concept_10825](./img/b_concept_10825.png)

![b_concept_101110](./img/b_concept_101110.png)
